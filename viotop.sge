#!/bin/sh
# vi: set ft=sh noet ts=8 sw=8 :: Vi/ViM
############################################################ IDENT(1)
#
# $Title: Script to generate top-like statistics for VFS I/O under Linux $
# $Copyright: 2020 Devin Teske. All rights reserved. $
# $FrauBSD: viotop/viotop.sge 2020-05-27 22:54:17 +0000 freebsdfrau $
#
############################################################ INFORMATION
#
# In viotop, a ``view'' is the user's choice between -c, -p, -g, -s, -t, or -u.
# For example, `-u' asks viotop to display the ``user view'' where statistics
# displayed are on a per-user basis.
#
# The code is broken down into:
# 	- View selection (user choice)
# 	- Filter selection (user choice)
# 	- Inspection of running system
# 	- bpftrace and bpftool execution
# 	- awk to process bpftrace output
#
# Code navigating Search Terms/ST:
# 	BPFTRACE	Start of bpftrace
# 	FILTERS		Data filters
# 	JSONDATA	JSON data generation
# 	OPS		Data operations (read vs write)
# 	POST		bpftrace post-processor (awk)
# 	PRE		Start of pre-processor (sh)
# 	SUBTOTALS	Subtotal generation
# 	TRACEDATA	bpftrace data generation and processing
# 	VIEWDATA	View data generation
# 	VIEWS		View processing
#
############################################################ DEFAULTS

DEFAULT_INTERVAL=2.0 # seconds

############################################################ GLOBALS

VERSION='$Version: 8.4 $'

pgm="${0##*/}" # Program basename

#
# Global exit status
#
SUCCESS=0
FAILURE=1

#
# Command-line options
#
COLOR=1					# -C
DEBUG=					# -d
DEBUGGER=				# -D
FILTER_FOLLOW=				# -f
FILTER_GROUP=				# -G group
FILTER_PID=				# -P pid
FILTER_SGE=				# -S job
FILTER_TYPE=				# -T type
FILTER_USER=				# -U user
IGNORE_RUNNING=				# -I
INTERVAL=$DEFAULT_INTERVAL		# -i sec
NO_NAMES=				# -n
NSAMPLES=				# -N num
OUTPUT_JSON=				# -j
QUIET=					# -q
RAW_VIEW=				# -r
REDACT=${VIOTOP_REDACT:+1}		# -R
SHOW_AGGREGATES=			# -a
SHOW_BYTES=				# -b
VIEW_AGGREGATES=			# -A
VIEW_COMM=				# -c
VIEW_GROUP=				# -g
VIEW_PID=				# -p (default)
VIEW_SGE=				# -s
VIEW_TYPE=				# -t
VIEW_USER=				# -u
WIDE_VIEW=				# -w

#
# Miscellaneous
#
CONS=1
[ -t 1 ] || CONS= COLOR= # stdout is not a tty
FILTER_COMM=
FILTER_GID=
FILTER_UID=
FOLLOW_PIDS=
FORK_CONDITION=
INTERVAL_PROBE= # Calculated
INTERVAL_SECONDS= # Raw value for awk
MAP_ID_FOLLOW=
MAP_ID_SGE=
MAP_ID_TRACE=
OPEN_CONDITION=
OPEN_FDS=
SGE_CONDITION=
SGE_JOBS=
VIEW=

############################################################ FUNCTIONS

die()
{
	local fmt="$1"
	if [ "$fmt" ]; then
		shift 1 # fmt
		printf "%s: $fmt\n" "$pgm" "$@" >&2
	fi
	exit $FAILURE
}

usage()
{
	local fmt="$1"
	local optfmt="\t%-11s %s\n"

	exec >&2
	if [ "$fmt" ]; then
		shift 1 # fmt
		printf "%s: $fmt\n" "$pgm" "$@"
	fi

	printf "Usage: %s [OPTIONS] [--] [comm]\n" "$pgm"
	printf "Options:\n"
	printf "$optfmt" "-a" "Show aggregate subtotals."
	printf "$optfmt" "-b" "Show bytes instead of bandwidth."
	printf "$optfmt" "-A" "Only show aggregate subtotals."
	printf "$optfmt" "-C" "Always enable color."
	printf "$optfmt" "-c" "View read/write activity by command name."
	printf "$optfmt" "-D" "Enable debugger."
	printf "$optfmt" "-d" "Debug. Print bpftrace script and exit."
	printf "$optfmt" "-G group" "Group filter (name or id)."
	printf "$optfmt" "-g" "View read/write activity by group."
	printf "$optfmt" "-h" "Print usage statement and exit."
	printf "$optfmt" "-I" "Ignore already-running processes."
	printf "$optfmt" "-i sec" \
		"Set interval seconds. Default \`$DEFAULT_INTERVAL'."
	printf "$optfmt" "-J" "Output most JSON data. Same as \`-ajgstu'."
	printf "$optfmt" "-j" "Output JSON formatted data."
	printf "$optfmt" "-N num" "Perform num samples and exit."
	printf "$optfmt" "-n" "Do not attempt to map uid/gid to names."
	printf "$optfmt" "-o" "Force non-console output."
	printf "$optfmt" "-P pid" "Process ID filter."
	printf "$optfmt" "-p" "View read/write activity by PID (default)."
	printf "$optfmt" "-q" "Quiet. Hide informational messages."
	printf "$optfmt" "-R" "Redact potentially sensitive information."
	printf "$optfmt" "-r" "Raw view. Do not format output of bpftrace."
	printf "$optfmt" "-S job" "Filter on SGE job id (regex)."
	printf "$optfmt" "-s" "View read/write activity by SGE job."
	printf "$optfmt" "-T type" "Filter on filesystem type."
	printf "$optfmt" "-t" "View read/write activity by VFS type."
	printf "$optfmt" "-U user" "User filter (name or id)."
	printf "$optfmt" "-u" "View read/write activity by user."
	printf "$optfmt" "-v" "Print version and exit."
	printf "$optfmt" "-w" "Wide view. Maximize width of first column."

	die
}

run_lsof()
{
	[ "$DEBUG" ] && return

	case "$FILTER_TYPE" in
	""|nfs*) lsof -X -N +c 0 ;;
	esac

	case "$FILTER_TYPE" in
	nfs*) : skip ;;
	*) lsof -X +c 0 +e /
	esac
}

run_bpftrace()
{
	if [ "$DEBUG" ]; then
		cat
		return
	fi

	bpftrace -B none /dev/stdin "$@"
}

count()
{
	local OPTIND=1 OPTARG __flag
	local __delim="$IFS"
	local __var_to_set=

	while getopts d:s: __flag; do
		case "$__flag" in
		d) __delim="$OPTARG" ;;
		s) __var_to_set="$OPTARG" ;;
		esac
	done
	shift $(( $OPTIND - 1 ))

	local IFS="$__delim"
	set -- $*
	if [ "$__var_to_set" ]; then
		eval $__var_to_set=$#
	else
		echo $#
	fi
}

getword()
{
	local funcname=getword
	local OPTIND=1 OPTARG __flag
	local __delim="$IFS"
	local __var_to_set=
	local __word=

	while getopts d:s:w: __flag; do
		case "$__flag" in
		d) __delim="$OPTARG" ;;
		s) __var_to_set="$OPTARG" ;;
		w) __word="$OPTARG" ;;
		esac
	done
	shift $(( $OPTIND - 1 ))

	case "$__word" in
	""|*[!0-9]*) die "$funcname: \`-w' requires a number" ;;
	esac

	local IFS="$__delim"
	set -- $*
	if [ "$__var_to_set" ]; then
		eval $__var_to_set=\"\$\{$__word\}\"
	else
		eval echo \"\$\{$__word\}\"
	fi
}

num2bytes()
{
	local __num="$1" __size="${2%B}" __var_to_set="$3"
	local __out=
	while [ $__size -gt 0 ]; do
		__out="$__out $(( $__num % 256 ))"
		__num=$(( $__num >> 8 ))
		__size=$(( $__size - 1 ))
	done
	__out="${__out# }"
	if [ "$__var_to_set" ]; then
		eval $__var_to_set=\"\$__out\"
	else
		echo "$__out"
	fi
}

bpf_prog_id()
{
	local __pid="$1" __prog="$2" __var_to_set="$3"
	local __ls __out __res

	[ "$__pid" -a "$__prog" ] || return ${FAILURE:-1}

	__ls=$( ls -l /proc/$__pid/fd 2> /dev/null ) || return
	__out=$( echo "$__ls" | awk -v pid=$__pid -v prog="$__prog" '
		$NF == "anon_inode:bpf-prog" {
			fd = $(NF-2)
			fdinfo = sprintf("/proc/%d/fdinfo/%d", pid, fd)
			id = ""
			while (getline < fdinfo > 0) {
				if ($1 != "prog_id:") continue
				id = $2
				break
			}
			close(fdinfo)
			if (id == "") next
			cmd = sprintf("bpftool prog show id %d", id)
			if (cmd | getline <= 0 || $4 != prog) {
				close(cmd)
				next
			}
			print id
			exit found = 1
		}
		END { exit found ? 0 : 3 }
	' )
	__res=$?

	if [ "$__var_to_set" ]; then
		eval $__var_to_set=\"\$__out\"
	else
		echo "$__out"
	fi

	return $__res
}

bpf_map_ids()
{
	local __prog="$1" __var_to_set="$2"
	local __out __res

	[ "$__prog" ] || return ${FAILURE:-1}

	__out=$( bpftool prog show id $__prog ) || return
	__out=$( echo "$__out" | awk '
		$(NF-1) == "map_ids" {
			print $NF
			found = 1
			exit
		}
		END { exit found ? 0 : 3 }
	' )
	__res=$?

	if [ "$__var_to_set" ]; then
		eval $__var_to_set=\"\$__out\"
	else
		echo "$__out"
	fi

	return $__res
}

#
# ST: CALLS
#

send_user()
{
	local type="$1"
	shift 1 # type
	printf "%s|%s\n" "$type" "$*"
}

info() { send_user info "$*"; }
info_n() { send_user info-n "$*"; }
msg() { send_user msg "$*"; }
warn() { send_user warn "$*"; }

resize()
{
	local size
	if [ -e /dev/tty ]; then
		size=$( stty size < /dev/tty 2> /dev/null )
	else
		size=$( stty size 2> /dev/null )
	fi
	send_user resize "${size:-24 80}"
}

############################################################ MAIN

#
# Process command-line options
#
while getopts AabCcDdfG:ghIi:JjN:noP:pqRrS:sT:tU:uvw flag; do
	case "$flag" in
	A) VIEW_AGGREGATES=1 SHOW_AGGREGATES=1 ;;
	a) SHOW_AGGREGATES=1 ;;
	b) SHOW_BYTES=1 ;;
	C) COLOR=1 ;;
	c) VIEW=COMM VIEW_COMM=1 ;;
	D) DEBUGGER=1 RAW_VIEW=1 ;;
	d) DEBUG=1 RAW_VIEW=1 ;;
	f) FILTER_FOLLOW=1 ;;
	G) FILTER_GROUP="$OPTARG" ;;
	g) VIEW=GROUP VIEW_GROUP=1 ;;
	I) IGNORE_RUNNING=1 ;;
	i) INTERVAL="$OPTARG" ;;
	J) VIEW=JSON OUTPUT_JSON=1 SHOW_AGGREGATES=1 \
		VIEW_GROUP=1 VIEW_SGE=1 VIEW_TYPE=1 VIEW_USER=1 ;;
	j) OUTPUT_JSON=1 ;;
	N) [ "$OPTARG" ] || usage "-N option requires an argument" # NOTREACHED
		NSAMPLES="$OPTARG" ;;
	n) NO_NAMES=1 ;;
	o) CONS= COLOR= ;;
	P) FILTER_PID="$OPTARG" ;;
	p) VIEW=PID VIEW_PID=1 ;;
	q) QUIET=1 ;;
	R) REDACT=1 ;;
	r) RAW_VIEW=1 ;;
	S) FILTER_SGE="$OPTARG" ;;
	s) VIEW=SGE VIEW_SGE=1 ;;
	T) FILTER_TYPE="$OPTARG" ;;
	t) VIEW=TYPE VIEW_TYPE=1 ;;
	U) FILTER_USER="$OPTARG" ;;
	u) VIEW=USER VIEW_USER=1 ;;
	v) VERSION="${VERSION#*: }"
		echo "${VERSION% $}"
		exit $SUCCESS ;;
	w) WIDE_VIEW=1 ;;
	*) usage # NOTREACHED
	esac
done
shift $(( $OPTIND - 1 ))

#
# Process command-line arguments
#
[ $# -le 1 ] || usage "Too many arguments" # NOTREACHED
FILTER_COMM="$1"

#
# Prevent non-functional option combinations
#
if [ "$SHOW_BYTES" ]; then
	[ "$VIEW" != "JSON" ] || die "-b cannot be combined with -J"
	[ ! "$OUTPUT_JSON" ] || die "-b cannot be combined with -j"
fi
case "$VIEW" in
PID) [ "$OUTPUT_JSON" ] || die "-p requires either -j or -J" ;;
esac

#
# Silently ignore previous view options unless JSON output
#
[ "$VIEW" ] || VIEW=PID VIEW_PID=1
if [ ! "$OUTPUT_JSON" ]; then
	case "$VIEW" in # ST: VIEWS
	COMM) VIEW_GROUP= VIEW_PID= VIEW_SGE= VIEW_TYPE= VIEW_USER= ;;
	GROUP) VIEW_COMM= VIEW_PID= VIEW_SGE= VIEW_TYPE= VIEW_USER= ;;
	PID) VIEW_COMM= VIEW_GROUP= VIEW_SGE= VIEW_TYPE= VIEW_USER= ;;
	SGE) VIEW_COMM= VIEW_GROUP= VIEW_PID= VIEW_TYPE= VIEW_USER= ;;
	TYPE) VIEW_COMM= VIEW_GROUP= VIEW_PID= VIEW_SGE= VIEW_USER= ;;
	USER) VIEW_COMM= VIEW_GROUP= VIEW_PID= VIEW_SGE= VIEW_TYPE= ;;
	esac
fi

#
# Process `-f' option
#
if [ "$FILTER_FOLLOW" ]; then
	[ "$FILTER_COMM$FILTER_GROUP$FILTER_PID$FILTER_SGE$FILTER_USER" ] ||
		die "-f requires at least one -G, -P, -S, -U, or comm argument"
fi

#
# Validate `-i sec' option
#
case "$INTERVAL" in
"") usage "missing -i argument" ;; # NOTREACHED
0) die "-i sec must be non-zero" ;;
*[!0-9.]*|*.*.*|.) die "-i sec must be a number" ;;
*.*)
	INTERVAL_SECONDS=$INTERVAL
	ms=$( echo "$INTERVAL * 1000" | bc )
	ms="${ms%%.*}"

	#
	# If, after multiplying by 1000 to convert sec to msec,
	# the leading [non-decimal] digit is either missing or zero,
	# the input was too small to produce timing of at least 1 msec
	#
	case "$ms" in
	""|0) die "-i sec must be at least 0.001" ;;
	esac

	INTERVAL_PROBE=interval:ms:$ms
	;;
*)
	INTERVAL_SECONDS=$INTERVAL
	INTERVAL_PROBE=interval:s:$INTERVAL_SECONDS
esac

#
# Validate `-N num' option
#
case "$NSAMPLES" in
0) die "-N num must be non-zero" ;;
*[!0-9]*) die "-N num must be a positive integer" ;;
esac

#
# Process `-G group'/`-U user' option
#
case "$FILTER_GROUP" in
"") : leave-empty ;;
*[!0-9]*) # Translate from name to GID
	FILTER_GID=$( getent group "$FILTER_GROUP" ) ||
		die "Unknown group \`%s'" "$FILTER_GROUP"
	FILTER_GID=$( echo "$FILTER_GID" | awk -F: '{print $3}' )
	;;
*) # Translate from GID to name
	FILTER_GID=$FILTER_GROUP
	FILTER_GROUP=$( getent group $FILTER_GID ) ||
		die "Unknown group id %d" "$FILTER_GID"
	FILTER_GROUP=$( echo "$FILTER_GROUP" | awk -F: '{print $1}' )
esac
case "$FILTER_USER" in
"") : leave-empty ;;
*[!0-9]*) # Translate from name to UID
	FILTER_UID=$( getent passwd "$FILTER_USER" ) ||
		die "Unknown user \`%s'" "$FILTER_USER"
	FILTER_UID=$( echo "$FILTER_UID" | awk -F: '{print $3}' )
	;;
*) # Translate from UID to name
	FILTER_UID=$FILTER_USER
	FILTER_USER=$( getent passwd $FILTER_UID ) ||
		die "Unknown user id %d" "$FILTER_UID"
	FILTER_USER=$( echo "$FILTER_USER" | awk -F: '{print $1}' )
esac

#
# Validate `-P pid' option
#
case "$FILTER_PID" in
"") : leave-empty ;;
0) die "-P pid must be non-zero" ;;
*[!0-9]*) die "-P pid must be a positive integer" ;;
esac

#
# Get terminal size
#
size=$( resize )
size="${size#*|}"
if [ "$size" ]; then
	cols="${size#*[$IFS]}"
	rows="${size%%[$IFS]*}"
fi
case "$rows$cols" in
""|*[!0-9]*)
	cols=80
	rows=24
	;;
esac

#
# Fixup PATH
#
case "$PATH" in
/usr/sbin:*|*:/usr/sbin:*|*:/usr/sbin) : ok ;;
*) PATH="${PATH:+$PATH:}/usr/sbin"
esac

#
# Run script
# ST: PRE
#
{
	exec 3<&1

	trap resize WINCH

	#
	# Find SGE processes and their children
	#
	if [ ! "$IGNORE_RUNNING$FILTER_PID$DEBUG" ]; then
		info_n "Gathering SGE job info... "
		SGE_JOBS=$( pgrep sge_shepherd | xargs -r -n1 pgrep \
			${FILTER_GROUP:+-G "$FILTER_GROUP"} \
			${FILTER_USER:+-U "$FILTER_USER"} -P 2> /dev/null |
			xargs -r -n1 pstree -p 2> /dev/null | awk \
			-v debug=${DEBUG:-0} \
			-v filter_sge="$FILTER_SGE" \
			-v sq="'" \
			-v stderr=/dev/stderr \
		'####################################### BEGIN

		BEGIN {
			job_pid = job_name = ""
			nactive = njobs = job_found = 0
			delete jobs_seen

			want_sge = ""
			if (filter_sge ~ /^[0-9]+$/) {
				want_sge = "id"
			} else if (filter_sge != "") {
				want_sge = "regex"
				gsub(/\\/, "&&", filter_sge)
			}
		}

		######################################## FUNCTIONS

		function emit(str)
		{
			if (debug) return
			printf "%s\n", str
			fflush()
		}

		function send_user(type, str)
		{
			emit(sprintf("%s|%s", type, str))
		}

		function info(str) { send_user("info", str) }
		function info_n(str) { send_user("info-n", str) }
		function msg(str) { send_user("msg", str) }
		function warn(str) { send_user("warn", str) }

		function getstatus(pid,        file, L)
		{
			comm = pcomm = ""
			uid = gid = puid = pgid = ppid = 0

			file = sprintf("/proc/%d/status", pid)
			while (getline L < file > 0) {
				if (sub(/^PPid:[[:space:]]*/, "", L)) {
					ppid = L
				} else if (sub(/^Name:[[:space:]]*/, "", L)) {
					comm = L
				} else if (sub(/^Uid:[[:space:]]*/, "", L)) {
					sub(/[[:space:]].*/, "", L)
					uid = L
				} else if (sub(/^Gid:[[:space:]]*/, "", L)) {
					sub(/[[:space:]].*/, "", L)
					gid = L
				}
			}
			close(file)
			if (ppid == 0) return 0

			file = sprintf("/proc/%d/status", ppid)
			while (getline L < file > 0) {
				if (sub(/^Name:[[:space:]]*/, "", L)) {
					pcomm = L
				} else if (sub(/^Uid:[[:space:]]*/, "", L)) {
					sub(/[[:space:]].*/, "", L)
					puid = L
				} else if (sub(/^Gid:[[:space:]]*/, "", L)) {
					sub(/[[:space:]].*/, "", L)
					pgid = L
				}
			}
			close(file)

			return 1
		}

		function checkjob(pid,        file, L, nv, env, n, ev, found)
		{
			found = 0
			job_id = 0
			jop_name = ""
			file = sprintf("/proc/%d/environ", pid)
			while (getline L < file > 0) {
				nv = split(L, env, /\0/)
				for (n = 1; n <= nv; n++) {
					ev = env[n]
					if (sub(/^JOB_ID=/, "", ev)) {
						job_id = ev
					} else if (sub(/^JOB_NAME=/, "", ev)) {
						job_name = ev
					}
					if (job_id > 0 && job_name != "") {
						found = 1
						break
					}
				}
				if (found) break
			}
			close(file)
			return job_id != ""
		}

		######################################## MAIN

		match($0, /^[^[:space:](]+\([0-9]+\)/) {
			njobs++
			job_pid = $0
			sub(/^[^(]*\(/, "", job_pid)
			sub(/\).*/, "", job_pid)

			if (!checkjob(job_pid)) next

			if (want_sge == "id") {
				if (job_id != filter_sge) next
				job_found = 1
			} else if (want_sge == "regex") {
				if (job_id !~ filter_sge &&
				    job_name !~ filter_sge) next
				job_found = 1
			}
		}

		job_pid != "" {
			gsub(/[^0-9]/, " ")
			gsub(/[[:space:]]+/, " ")
			gsub(/(^[[:space:]]+|[[:space:]]+$)/, "")

			npids = split($0, pids, /[[:space:]]+/)
			for (n = 1; n <= npids; n++) {
				if (!getstatus(pids[n])) continue
				nactive++

				#
				# Print to stdout
				# NB: default = awk, raw [-r] = stdout
				#
				if (pids[n] == job_pid) {
					emit(sprintf("fork_job|%d", job_pid))
				}

				# To bpftool map update
				printf "%d=%d\n", pids[n], job_pid > stderr
			}

			if (job_found) exit
		}

		######################################## END

		END {
			msg(sprintf("%d %s found", njobs,
				njobs == 1 ? "job" : "jobs"))
			if (want_sge != "" && !job_found) {
				if (want_sge == "regex") {
					fmt = "No SGE jobs matching `%s" sq
				} else if (want_sge == "id") {
					fmt = "SGE job %d not found"
				}
				warn(sprintf(fmt, filter_sge))
			}
		}
		' 2>&1 >&3 ) || die "%s" "$SGE_JOBS"
	fi

	#
	# Find matching processes and their children
	#
	if [ "$FILTER_FOLLOW" -a ! "$IGNORE_RUNNING$DEBUG" ]; then
		info "Gathering active process info..."
		if [ "$FILTER_PID" ]; then
			FOLLOW_PIDS=$( pstree -p $FILTER_PID | awk \
				-v filter_group="$FILTER_GROUP" \
				-v filter_user="$FILTER_USER" '
			BEGIN { delete seen }
			function del(re){gsub(re,"")}
			function space(re){gsub(re," ")}
			function check_group(pid,        file, gid, L) {
				if (filter_group == "") return 1 # OK
				gid = ""
				file = sprintf("/proc/%d/status", pid)
				while (getline L < file > 0) {
					if (L !~ /^Gid:/) next
					sub(/^Gid:[[:space:]]*/, "", L)
					sub(/[^0-9].*/, "", L)
					gid = L
					break
				}
				close(file)
				return gid == filter_group
			}
			function check_user(pid,        file, uid, L) {
				if (filter_user == "") return 1 # OK
				uid = ""
				file = sprintf("/proc/%d/status", pid)
				while (getline L < file > 0) {
					if (L !~ /^Uid:/) next
					sub(/^Uid:[[:space:]]*/, "", L)
					sub(/[^0-9].*/, "", L)
					uid = L
					break
				}
				close(file)
				return uid == filter_user
			}
			match($0, /^[^[:space:](]+\([0-9]+\)/) {
				pid = substr($0, 1, RLENGTH - 1)
				$0 = substr($0, RLENGTH + 1)
				sub(/.*\(/, "", pid)
				if (!(pid in seen)) pids = pids " " pid
			}
			{
				space("[^0-9]")
				space("[[:space:]]+")
				del("(^[[:space:]]+|[[:space:]]+$)")
				npids = split($0, list)
				for (n = 1; n <= npids; n++) {
					if ((pid = list[n]) in seen) continue

					# group filter
					if (!check_group(pid)) continue

					# user filter
					if (!check_user(pid)) continue

					pids = pids " " pid
					seen[pid]
				}
			}
			END { print substr(pids, 2) }
			' )
		elif [ "$FILTER_COMM$FILTER_USER$FILTER_GROUP" ]; then
			FOLLOW_PIDS=$( pgrep ${FILTER_COMM:+"$FILTER_COMM"} \
				${FILTER_USER:+-U "$FILTER_USER"} \
				${FILTER_GROUP:+-G "$FILTER_GROUP"} |
				awk '
			BEGIN { delete seen }
			function del(re){gsub(re,"")}
			function space(re){gsub(re," ")}
			match($0, /^[^[:space:](]+\([0-9]+\)/) {
				pid = substr($0, 1, RLENGTH - 1)
				$0 = substr($0, RLENGTH + 1)
				sub(/.*\(/, "", pid)
				if (!(pid in seen)) pids = pids " " pid
			}
			{
				space("[^0-9]")
				space("[[:space:]]+")
				del("(^[[:space:]]+|[[:space:]]+$)")
				npids = split($0, list)
				for (n = 1; n <= npids; n++) {
					if ((pid = list[n]) in seen) continue
					pids = pids " " pid
					seen[pid]
				}
			}
			END { print substr(pids, 2) }
			' )
		fi
	fi

	#
	# Find open *file* descriptors
	#
	if [ ! "$IGNORE_RUNNING$DEBUG" ]; then
		info "Gathering open file-descriptor info" \
		     "(this may take a while)..."
		OPEN_FDS=$( run_lsof | awk \
			-v debug=${DEBUG:-0} \
			-v filter_comm="$FILTER_COMM" \
			-v filter_follow=${FILTER_FOLLOW:-0} \
			-v filter_gid="$FILTER_GID" \
			-v filter_sge="$FILTER_SGE" \
			-v filter_pid="$FILTER_PID" \
			-v filter_type="$FILTER_TYPE" \
			-v filter_user="$FILTER_USER" \
			-v follow_pids="$FOLLOW_PIDS" \
			-v sge_jobs="$SGE_JOBS" \
			-v stderr=/dev/stderr \
		'####################################### BEGIN

		BEGIN {
			delete follow
			nfollow = split(follow_pids, list)
			for (n = 1; n <= nfollow; n++) {
				follow[list[n]]
			}

			delete mounts
			delete mount_type
			file = "/proc/mounts"
			nmounts = 0
			root_mount = ""
			root_mount_type = ""
			flen = length(filter_type)
			while (getline < file > 0) {
				if (filter_type != "" &&
				    substr($3, 1, flen) != filter_type)
					continue
				if ($2 == "/") {
					root_mount = $2
					root_mount_type = $3
				} else {
					mounts[++nmounts] = $2
					sub("/+$", "", mounts[nmounts])
					mount_type[nmounts] = $3
				}
			}
			close(file)
			if (root_mount != "") {
				mounts[++nmounts] = root_mount
				mount_type[nmounts] = root_mount_type
			}

			delete job_pids
			njobs = split(sge_jobs, list)
			for (n = 1; n <= njobs; n++) {
				pid = job_pid = list[n]
				sub(/=.*/, "", pid)
				sub(/.*=/, "", job_pid)
				job_pids[pid] = job_pid
			}

			delete seen
		}

		######################################## FUNCTIONS

		function key(a, b) { return a "," b }

		function emit(str)
		{
			if (debug) return
			printf "%s\n", str
			fflush()
		}

		function send_user(type, str)
		{
			emit(sprintf("%s|%s", type, str))
		}

		function info(str) { send_user("info", str) }
		function info_n(str) { send_user("info-n", str) }
		function msg(str) { send_user("msg", str) }
		function warn(str) { send_user("warn", str) }

		function getcol(name,        start, width, val)
		{
			start = startcol[name]
			width = colwidth[name]
			if (start < 1) return ""
			if (name == lastcol)
				val = substr($0, start)
			else
				val = substr($0, start, width)
			gsub(/(^[[:space:]]+|[[:space:]]+$)/, "", val)
			return val
		}

		######################################## MAIN

		# Header
		$1 == "COMMAND" && $2 == "PID" && $NF == "NAME" {
			delete cols
			delete startcol
			delete colwidth
			ncol = split($0, cols, /[[:space:]]+/)
			for (n = 1; n <= ncol; n++) {
				col = cols[n]
				if (n == 1) { # First col
					# NB: Left-justified
					match($0, /^[^ ]+ +/)
					startcol[col] = RSTART
					colwidth[col] = RLENGTH - 3
				} else if (n == 2) { # Second col
					# NB: Right-justified
					match($0, " " col " ")
					startcol[col] = RSTART - 2
					colwidth[col] = RLENGTH + 1
				} else if (n == ncols) { # Last col
					# NB: Left-justified
					match($0, / [^ ]+$/)
					startcol[col] = RSTART + 1
				} else {
					# NB: Right-justified
					pcol = cols[n - 1]
					startcol[col] = startcol[pcol]
					startcol[col] += colwidth[pcol] + 1
					match($0, " " col " ")
					colwidth[col] = RSTART + RLENGTH - 1
					colwidth[col] -= startcol[col]
					# NB: FD column has 1B tag
					if (col == "FD") colwidth[col]++
				}
			}
			lastcol = col
			next
		}

		# Parse fields
		{
			cmd  = getcol("COMMAND")
			pid  = getcol("PID")
			tid  = getcol("TID")
			user = getcol("USER")
			fd   = getcol("FD")
			type = getcol("TYPE")
			dev  = getcol("DEVICE")
			size = getcol("SIZE/OFF")
			node = getcol("NODE")
			name = getcol("NAME")

			# Treat effects of "lsof +e /"
			sub(/^UNKN/, "", type)
			sub(" \\(\\+e /\\)$", "", name)

			if (filter_sge != "" && !(pid in job_pids)) next
			if (fd !~ /^[0-9]/) next
		}

		name ~ "^/" && type != "DIR" && fd ~ /^[0-9]+[rwu-]?$/ {

			sub(/[rwu-]$/, "", fd)
			if (key(pid, fd) in seen) next

			matched = 0
			for (n = 1; n <= nmounts; n++) {
				mnt = mounts[n]
				mnt_type = mount_type[n]
				len = length(mnt)
				pre = substr(name, 1, len + 1)
				if (mnt == "/" && name ~ "^/")
					matched = 1
				else if (name == mnt || pre == mnt "/")
					matched = 1
				if (matched) break
			}
			if (!matched) next

			#
			# ST: FILTERS
			#

			# follow filter
			if (filter_follow && !(pid in follow)) {
				next
			} else if (!filter_follow) {
				# NB: follow_pids should contain all the pids
				# that match the below criterion.

				# pid filter
				if (filter_pid != "" && pid != filter_pid) {
					next
				}

				# comm filter
				if (filter_comm != "" && cmd != filter_comm) {
					next
				}

				# user filter
				if (filter_user != "" && user != filter_user) {
					next
				}

				# group filter
				if (filter_gid != "") {
					gid = ""
					file = sprintf("/proc/%d/status", pid)
					while (getline L < file > 0) {
						if (L !~ /^Gid:/) continue
						sub(/^Gid:[[:space:]]*/, "", L)
						sub(/[^0-9].*/, "", L)
						gid = L
						break
					}
					close(file)
					if (gid != filter_gid) next
				}
			}

			#
			# Save information for later bpftool
			#
			printf "%d:%d:%s\n", pid, fd, mnt_type > stderr

			#
			# Prevent duplicate reporting
			# NB: In the case of multiple threads, for example
			#
			seen[key(pid, fd)]
		}
		' 2>&1 >&3 ) || die "%s" "$OPEN_FDS"
	fi

	#
	# Generate conditions
	# ST: FILTERS
	#
	condition=
	if [ "$FILTER_COMM" ]; then
		FILTER_COMM="\"$FILTER_COMM\""
		if [ "$FILTER_FOLLOW" ]; then
			# For tracepoint:sched:sched_process_fork
			condition="$condition && args->parent_comm"
			condition="$condition == $FILTER_COMM"
		else
			# For tracepoint:syscalls:sys_enter_open*
			condition="$condition && comm == $FILTER_COMM"
		fi
	fi
	if [ "$FILTER_GID" ]; then
		condition="$condition && gid == $FILTER_GID"
		SGE_CONDITION="$SGE_CONDITION && gid == $FILTER_GID"
	fi
	if [ "$FILTER_PID" ]; then
		condition="$condition && pid == $FILTER_PID"
	fi
	if [ "$FILTER_UID" ]; then
		condition="$condition && uid == $FILTER_UID"
		SGE_CONDITION="$SGE_CONDITION && uid == $FILTER_UID"
	fi
	condition="${condition# && }"
	if [ "$FILTER_FOLLOW" ]; then
		FORK_CONDITION="$condition"
		OPEN_CONDITION="@follow[pid]"
	else
		OPEN_CONDITION="$condition"
	fi

	#
	# Start background bpftrace
	# NB: M-x package-install [RET] dtrace-script-mode [RET]
	# ST: BPFTRACE
	#
	run_bpftrace <<EOF &
	${DEBUG:+#!/usr/bin/bpftrace}
	/* -*- mode: dtrace-script; tab-width: 4 -*- ;; Emacs
	 * vi: set ft=dtrace noet ts=4 sw=4 :: Vi/ViM
	 */
	////////////////////////////////////////////////// INCLUDES

	#include <linux/fs.h>
	#include <linux/mount.h>

	////////////////////////////////////////////////// BEGIN

	BEGIN
	{
		@trace[-1,-1] = ""; // Required to create map
		delete(@trace[-1,-1]); // Delete dummy entry

		@follow[-1] = 1;
		delete(@follow[-1]);

		@is_sge_job[-1] = 1;
		delete(@is_sge_job[-1]);

		time("time|%s\n");
		printf("init|"); // Initialize post-processor
		printf("===\n"); // Clear screen and draw header
		printf("info|Sampling data for ${INTERVAL}s (\`-i sec')...\n");
	}

	////////////////////////////////////////////////// FORK PROBE

	tracepoint:sched:sched_process_fork
	{
		\$parent_comm = args->parent_comm;
		\$parent_pid = args->parent_pid;
		\$child_pid = args->child_pid;
		\$job_pid = @is_sge_job[\$parent_pid];

${FILTER_FOLLOW:+"
		//
		// Flag follow-children
		//
		if ($FORK_CONDITION) {
			@follow[\$parent_pid] = 1;
		}
		if (@follow[\$parent_pid]) {
			@follow[\$child_pid] = 1;
		}
"}

		//
		// Flag SGE-children
		//
		if (\$parent_comm == "sge_shepherd") {
			@is_new_job[\$job_pid] = \$job_pid; // See kprobe:SyS_execve
			@is_sge_job[\$job_pid] = \$job_pid;
		}
		if (@is_sge_job[\$parent_pid]$SGE_CONDITION) {
			@is_sge_job[\$child_pid] = \$job_pid;
		}
	}

	////////////////////////////////////////////////// EXIT PROBE

	tracepoint:sched:sched_process_exit
	{
		\$comm = args->comm;
		\$pid = args->pid;
		\$job_pid = @is_sge_job[\$pid];

		//
		// Free flags
		//

${FILTER_FOLLOW:+
		delete(@follow[\$pid]);
}

		if (@is_sge_job[\$pid]$SGE_CONDITION) {
			delete(@is_sge_job[\$pid]);

			//
			// Tell post-processor that job sge_shepherd exited so
			// it can exit if '-S job' has been specified.
			//
			if (\$pid == \$job_pid) {
				printf("job_exit|%d\n", \$job_pid);
			}
		}
	}

	////////////////////////////////////////////////// EXECVE PROBE

	/*
	 * Watch job shepherds
	 */

	kprobe:SyS_execve
	/@is_new_job[pid]/
	{
		\$job_pid = pid;

		delete(@is_new_job[pid]);
			// See tracepoint:sched:sched_process_fork

		//
		// Tell post-processor that job sge_shepherd started so
		// it can cache the job id in association with job pid.
		//
		printf("fork_job|%d\n", \$job_pid);
	}

	////////////////////////////////////////////////// OPEN PROBES

	/*
	 * open(2)/openat(2) [enter] probes
	 */

$( for func in sys_enter_open sys_enter_openat; do
	name=${func#*enter_}
	cat <<PROBE
	tracepoint:syscalls:$func
	${OPEN_CONDITION:+/$OPEN_CONDITION/
	}{
		// Free vfs_open flags
		if (str(args->filename) != "") {
			delete(@vfs_${name}_trace[tid]);
			@vfs_$name[tid] = 1;
		}
	}

PROBE
done )

	/*
	 * NB: vfs_open() always called after open(2)/openat(2)
	 */

	kprobe:vfs_open
	{
		//
		// Extract the filesystem type from mount superblock
		//
		\$path = (struct path *)arg0;
		\$mnt = (struct vfsmount *)\$path->mnt;
		\$mnt_sb = (struct super_block *)\$mnt->mnt_sb;
		\$type = (struct file_system_type *)\$mnt_sb->s_type;
		\$fstype = \$type->name;

$( for func in sys_enter_open sys_enter_openat; do
		name=${func#*enter_}
		exit_func=${func%%enter_*}exit_$name
		cat <<PROBE
		if (@vfs_$name[tid]) {
			delete(@vfs_$name[tid]); // Flag from $func

			//
			// Test filesystem type (for $exit_func)
			//
$( if [ "$FILTER_TYPE" ]; then
			awk 'sub(/^\\/,"")||1' <<-FILTER_TYPE
\			if (str(\$fstype, ${#FILTER_TYPE}) == "$FILTER_TYPE") {
\				@vfs_${name}_trace[tid] = str(\$fstype);
\			}
			FILTER_TYPE
else
			awk 'sub(/^\\/,"")||1' <<-FILTER_TYPE
\			@vfs_${name}_trace[tid] = str(\$fstype);
			FILTER_TYPE
fi )
		}
PROBE
done )
	}

	/*
	 * open(2)/openat(2) [exit] probes
	 */

$( for func in sys_exit_open sys_exit_openat; do
	name=${func#*exit_}
	cat <<PROBE
	tracepoint:syscalls:$func
	/@vfs_${name}_trace[tid] != ""/
	{
		\$fstype = @vfs_${name}_trace[tid];

		delete(@vfs_${name}_trace[tid]); // Flag from vfs_open

		\$ret = args->ret;
		if (\$ret >= 0)
		{
			\$fd = (uint64)\$ret;

			// Set flag to trace read/write on fd
			@trace[pid, \$fd] = \$fstype;
		}
	}

PROBE
done )

	////////////////////////////////////////////////// DUP PROBES

	/*
	 * dup(2) probes
	 */

	tracepoint:syscalls:sys_enter_dup
	/@trace[pid, args->fildes] != ""/
	{
		\$fd = (int64)args->fildes;

		@dup_fd[tid] = \$fd; // Pass to sys_exit_dup
	}

	tracepoint:syscalls:sys_exit_dup
	/@dup_fd[tid]/
	{
		\$oldfd = (int64)@dup_fd[tid];
		\$newfd = (int64)args->ret;

		delete(@dup_fd[tid]); // Arg from sys_enter_dup

		if (\$oldfd != \$newfd)
		{
			// Set flag to trace read/write on fd
			@trace[pid, \$newfd] = @trace[pid, \$oldfd];
		}
	}

	/*
	 * dup2(2) probe
	 */

	tracepoint:syscalls:sys_enter_dup2
	/args->oldfd != args->newfd/
	{
		\$oldfd = (int64)args->oldfd;
		\$newfd = (int64)args->newfd;

		delete(@trace[pid, \$newfd]);

		if (@trace[pid, \$oldfd] != "") {
			// Set flag to trace read/write on fd
			@trace[pid, \$newfd] = @trace[pid, \$oldfd];
		}
	}

	/*
	 * dup3(2) probe
	 */

	tracepoint:syscalls:sys_enter_dup3
	/args->oldfd != args->newfd/
	{
		\$oldfd = (int64)args->oldfd;
		\$newfd = (int64)args->newfd;

		delete(@trace[pid, \$newfd]);

		// Set flag to trace read/write on fd
		if (@trace[pid, \$oldfd] != "") {
			@trace[pid, \$newfd] = @trace[pid, \$oldfd];
		}
	}

	/*
	 * fcntl(2) probe
	 */

	tracepoint:syscalls:sys_enter_fcntl
	/args->cmd == F_DUPFD && args->fd != args->arg/
	{
		\$oldfd = (int64)args->fd;
		\$newfd = (int64)args->arg;

		delete(@trace[pid, \$newfd]);

		// Set flag to trace read/write on fd
		if (@trace[pid, \$oldfd] != "") {
			@trace[pid, \$newfd] = @trace[pid, \$oldfd];
		}
	}

	////////////////////////////////////////////////// CLOSE PROBES

	/*
	 * close(2) probe
	 */

	tracepoint:syscalls:sys_enter_close
	/@trace[pid, args->fd] != ""/
	{
		\$fd = args->fd;
		\$fstype = @trace[pid, \$fd];

		delete(@trace[pid, \$fd]); // Stop tracing read/write on fd
	}

	////////////////////////////////////////////////// READ PROBES

	/*
	 * read(2) probes
	 */

	tracepoint:syscalls:sys_enter_read
	/@trace[pid, args->fd] != ""/
	{
		\$fd = args->fd;
		\$count = args->count;

		// Pass args to sys_exit_read
		@read_exit[tid] = 1;
		@read_fd[tid] = \$fd;
		@read_count[pid, \$fd] = \$count;
	}

	tracepoint:syscalls:sys_exit_read
	/@read_exit[tid]/
	{
		\$fd = @read_fd[tid];
		\$count = @read_count[pid, \$fd];
		\$ret = args->ret;
		\$fstype = @trace[pid, \$fd];
		\$job_pid = @is_sge_job[pid];

		// Args from sys_enter_read
		delete(@read_exit[tid]);
		delete(@read_fd[tid]);
		delete(@read_count[pid, \$fd]);

		if (\$ret > 0)
		{
			// ST: VIEWS TRACEDATA
${VIEW_COMM:+"
			@rd_comm[\$fstype, comm] = sum(\$count);
"}
${VIEW_GROUP:+"
			@rd_group[\$fstype, gid] = sum(\$count);
"}
${VIEW_PID:+"
			@rd_pid[\$fstype, pid, uid, comm, \$job_pid] = \
				sum(\$count);
"}
${VIEW_SGE:+"
			if (\$job_pid > 0) {
				@rd_sge[\$fstype, \$job_pid, uid] = \
					sum(\$count);
			}
"}
${VIEW_TYPE:+"
			@rd_type[\$fstype] = sum(\$count);
"}
${VIEW_USER:+"
			@rd_user[\$fstype, uid] = sum(\$count);
"}
		}
	}

	////////////////////////////////////////////////// WRITE PROBES

	/*
	 * write(2) probes
	 */

	tracepoint:syscalls:sys_enter_write
	/@trace[pid, args->fd] != ""/
	{
		\$fd = args->fd;
		\$count = args->count;

		// Pass args to sys_exit_write
		@write_exit[tid] = 1;
		@write_fd[tid] = \$fd;
		@write_count[pid, \$fd] = \$count;
	}

	tracepoint:syscalls:sys_exit_write
	/@write_exit[tid]/
	{
		\$fd = @write_fd[tid];
		\$count = @write_count[pid, \$fd];
		\$ret = args->ret;
		\$fstype = @trace[pid, \$fd];
		\$job_pid = @is_sge_job[pid];

		// Args from sys_enter_write
		delete(@write_exit[tid]);
		delete(@write_fd[tid]);
		delete(@write_count[pid, \$fd]);

		if (\$ret > 0)
		{
			// ST: VIEWS TRACEDATA
${VIEW_COMM:+"
			@wr_comm[\$fstype, comm] = sum(\$count);
"}
${VIEW_GROUP:+"
			@wr_group[\$fstype, gid] = sum(\$count);
"}
${VIEW_PID:+"
			@wr_pid[\$fstype, pid, uid, comm, \$job_pid] = \
				sum(\$count);
"}
${VIEW_SGE:+"
			if (\$job_pid > 0) {
				@wr_sge[\$fstype, \$job_pid, uid] = \
					sum(\$count);
			}
"}
${VIEW_TYPE:+"
			@wr_type[\$fstype] = sum(\$count);
"}
${VIEW_USER:+"
			@wr_user[\$fstype, uid] = sum(\$count);
"}
		}
	}

	////////////////////////////////////////////////// INTERVAL PROBE

	$INTERVAL_PROBE
	{
		time("time|%s\n");
		printf("===\n");

		// ST: VIEWS
${VIEW_COMM:+
		print(@rd_comm);
		print(@wr_comm);
		clear(@rd_comm);
		clear(@wr_comm);
}
${VIEW_GROUP:+
		print(@rd_group);
		print(@wr_group);
		clear(@rd_group);
		clear(@wr_group);
}
${VIEW_PID:+
		print(@rd_pid);
		print(@wr_pid);
		clear(@rd_pid);
		clear(@wr_pid);
}
${VIEW_SGE:+
		print(@rd_sge);
		print(@wr_sge);
		clear(@rd_sge);
		clear(@wr_sge);
}
${VIEW_TYPE:+
		print(@rd_type);
		print(@wr_type);
		clear(@rd_type);
		clear(@wr_type);
}
${VIEW_USER:+
		print(@rd_user);
		print(@wr_user);
		clear(@rd_user);
		clear(@wr_user);
}

		printf("---\n");
	}

	////////////////////////////////////////////////// END

	END
	{
${FILTER_FOLLOW:+
		clear(@follow);
}
		// ST: VIEWS
${VIEW_COMM:+
		clear(@rd_comm);
		clear(@wr_comm);
}
${VIEW_GROUP:+
		clear(@rd_group);
		clear(@wr_group);
}
${VIEW_PID:+
		clear(@rd_pid);
		clear(@wr_pid);
}
${VIEW_SGE:+
		clear(@is_new_job);
		clear(@is_sge_job);
		clear(@rd_sge);
		clear(@wr_sge);
}
${VIEW_TYPE:+
		clear(@rd_type);
		clear(@wr_type);
}
${VIEW_USER:+
		clear(@rd_user);
		clear(@wr_user);
}

		clear(@dup_fd);
		clear(@read_count);
		clear(@read_exit);
		clear(@read_fd);
		clear(@trace);
$( for func in sys_enter_open sys_enter_openat; do
		name=${func#*enter_}
		awk 'sub(/^\\/,"")||1' <<-CLEAR
\		clear(@vfs_$name);
\		clear(@vfs_${name}_trace);
		CLEAR
done )
		clear(@write_count);
		clear(@write_exit);
		clear(@write_fd);
	}

	//////////////////////////////////////////////////////////////////////
	// END
	//////////////////////////////////////////////////////////////////////
EOF
	pid=$!
	prog_id=
	map_ids=

	#
	# Identify child bpftrace
	#
	if [ ! "$DEBUG" ]; then
		info "Waiting for bpftrace to initialize..."
		while kill -0 $pid 2> /dev/null; do
			bpid=$( pgrep -P $pid bpftrace ) && break
			sleep 1
		done
		if ! kill -0 $pid 2> /dev/null; then
			wait $pid > /dev/null 2>&1 # Collect exit status
			echo EXIT:$? # Send status to post-processor
			exit
		fi
	fi
	if [ "$OPEN_FDS$FOLLOW_PIDS$SGE_JOBS" -a ! "$DEBUG" ]; then
		while kill -0 $bpid 2> /dev/null; do
			if [ ! "$prog_id" ]; then
				bpf_prog_id $bpid BEGIN prog_id
				if [ "$prog_id" ]; then
					bpf_map_ids $prog_id map_ids
					[ "$map_ids" ] && break
				fi
			elif [ ! "$map_ids" ]; then
				bpf_map_ids $prog_id map_ids
				[ "$map_ids" ] && break
			fi
			sleep 1
		done
		if ! kill -0 $pid 2> /dev/null; then
			wait $pid > /dev/null 2>&1 # Collect exit status
			echo EXIT:$? # Send status to post-processor
			exit
		fi

		#
		# Store map ids
		#
		getword -w 1 -s MAP_ID_TRACE  -d , $map_ids
		getword -w 2 -s MAP_ID_FOLLOW -d , $map_ids
		getword -w 3 -s MAP_ID_SGE    -d , $map_ids
	fi

	#
	# Update open file descriptor map
	#
	if [ "$OPEN_FDS" -a "$MAP_ID_TRACE" ]; then
		echo "$OPEN_FDS" | awk -v map_id="$MAP_ID_TRACE" '
		######################################## BEGIN

		BEGIN {
			nopen = 0
			delete open_pid
			delete open_fd
			delete open_type

			str_max = ENVIRON["BPFTRACE_STRLEN"]
			if (str_max == "") str_max = 64

			delete asc
			for (n = 0; n <= 255; n++)
				asc[sprintf("%c", n)] = n
		}

		######################################## FUNCTIONS

		function num2bytes(num, size,        buf)
		{
			buf = ""
			sub(/B$/, "", size)
			while (size > 0) {
				buf = buf " " (num % 256)
				num = rshift(num, 8)
				size--
			}
			return substr(buf, 2)
		}

		function str2bytes(str,        buf, chars, nchars, char, n, p)
		{
			buf = ""
			p = str_max
			delete chars
			str = substr(str, 1, str_max)
			nchars = split(str, chars, "")
			for (n = 1; n <= nchars; n++) {
				char = chars[n]
				p--
				buf = buf " " asc[char]
			}
			while (p-- > 0)
				buf = buf " 0"
			return substr(buf, 2)
		}

		######################################## MAIN

		nitems = split($0, list) {
			for (n = 1; n <= nitems; n++) {
				pid_fd_type = list[n]
				if (pid_fd_type == "") continue
				nopen++
				split(pid_fd_type, open, /:/)
				open_pid[nopen] = open[1]
				open_fd[nopen] = open[2]
				open_type[nopen] = open[3]
			}
		}

		######################################## END

		END {
			for (n = 1; n <= nopen; n++) {
				pid = open_pid[n]
				fd = open_fd[n]
				type = open_type[n]

				key = sprintf("%s %s",
					num2bytes(pid, "8B"),
					num2bytes(fd, "8B"))
				value = str2bytes(type)

				printf "map update id %d key %s value %s\n",
					map_id, key, value
			}
		}

		' | bpftool batch file /dev/stdin > /dev/null
		count -s cnt $OPEN_FDS
		info "Loaded $cnt fds into bpftrace map" \
			"(pid $bpid, prog $prog_id, map $MAP_ID_TRACE)"
	fi

	#
	# Update follow map
	#
	if [ "$FOLLOW_PIDS" -a "$MAP_ID_FOLLOW" ]; then
		count -s cnt $FOLLOW_PIDS
		for pid in $FOLLOW_PIDS; do
			num2bytes $pid 8B map_key
			num2bytes 1    8B map_value
			echo map update id $MAP_ID_FOLLOW \
				key $map_key value $map_value
		done | bpftool batch file /dev/stdin > /dev/null
		info "Loaded $cnt pids into bpftrace map" \
			"(pid $bpid, prog $prog_id, map $MAP_ID_FOLLOW)"
	fi

	#
	# Update SGE job map
	#
	if [ "$SGE_JOBS" -a "$MAP_ID_SGE" ]; then
		count -s cnt $SGE_JOBS
		for pid_ppid in $SGE_JOBS; do
			pid="${pid_ppid%%=*}" ppid="${pid_ppid#*=}"
			num2bytes $pid  8B map_key
			num2bytes $ppid 8B map_value
			echo map update id $MAP_ID_SGE \
				key $map_key value $map_value
		done | bpftool batch file /dev/stdin > /dev/null
		info "Loaded $cnt SGE pids into bpftrace map" \
			"(pid $bpid, prog $prog_tag, map $MAP_ID_SGE)"
	fi

	#
	# Wait on background (bpftrace) child
	#
	status_collected=
	while kill -0 $bpid > /dev/null 2>&1; do
		wait > /dev/null 2>&1 # Collect exit status
		[ "$status_collected" ] || status_collected=$?
	done
	echo EXIT:$status_collected # Send status to post-processor

} | awk -v color=${COLOR:-0} \
	-v cols=$cols \
	-v cons=${CONS:-0} \
	-v debug=${DEBUG:-0} \
	-v debugger=${DEBUGGER:-0} \
	-v filter_sge="$FILTER_SGE" \
	-v filter_type=${FILTER_TYPE:+1} \
	-v interval=$INTERVAL_SECONDS \
	-v no_names=${NO_NAMES:-0} \
	-v nsamples=${NSAMPLES:-0} \
	-v output_json=${OUTPUT_JSON:-0} \
	-v quiet=${QUIET:-0} \
	-v raw_view=${RAW_VIEW:-0} \
	-v redact=${REDACT:-0} \
	-v rows=$rows \
	-v show_aggregates=${SHOW_AGGREGATES:-0} \
	-v show_bytes=${SHOW_BYTES:-0} \
	-v stderr=/dev/stderr \
	-v view="$VIEW" \
	-v view_aggregates=${VIEW_AGGREGATES:-0} \
	-v wide_view=${WIDE_VIEW:-0} \
	'####################################### BEGIN

	# ST: POST

	BEGIN {
		debug2("Terminal size (rows, cols) = (%d, %d)", rows, cols)

		exit_status = 0 # SUCCESS
		time_delta = 0 # Calculated
		samples_left = nsamples
		tm = systime()

		inv	= "\033[7m"
		noinv	= "\033[27m"
		bold    = "\033[1m"
		nobold  = "\033[22m"
		red     = "\033[31m"
		green   = "\033[32m"
		yellow  = "\033[33m"
		magenta = "\033[35m"
		cyan    = "\033[36m"
		fgreset = "\033[39m"

		# Obtain current process (awk) pid
		(cmd = "echo $PPID") | getline apid
		close(cmd)

		# Obtain parent process (sh) pid
		getline stat < (file = sprintf("/proc/%d/stat", apid))
		close(file)
		split(stat, st)
		spid = st[4]

		# Obtain parent process (sh) name
		getline stat < (file = sprintf("/proc/%d/stat", spid))
		close(file)
		split(stat, st)
		comm = st[2]
		if (match(comm, /^\(.*\)$/))
			comm = substr(comm, 2, length(comm) - 2)

		# Obtain child (sh) pid
		(cmd = sprintf("pgrep -P %d %s", spid, comm)) | getline cpid
		close(cmd)

		if (!raw_view) {
			clear_data()
			resize()
		}

		want_sge = ""
		if (filter_sge ~ /^[0-9]+$/) {
			want_sge = "id"
		} else if (filter_sge != "") {
			want_sge = "regex"
			gsub(/\\/, "&&", filter_sge)
		}

		# Declare arrays
		delete jobcache
		delete namecache
		delete times
		delete uid2name_cache
		delete gid2name_cache

		if (redact) {
			m = "^(USER|total|"
			if ((u = ENVIRON["USER"]) != "")
				m = m u "|"
			if ((s = ENVIRON["SUDO_USER"]) != "" && s != u)
				m = m s "|"
			cmd = "getent passwd 2> /dev/null"
			while (cmd | getline > 0) {
				if (split($0, f, /:/) < 3) continue
				if (f[3] > 1024 && f[3] !~ /^6553[456]$/)
					continue
				m = m f[1] "|"
			}
			close(cmd)
			m = m "\\*)$"
			unredacted_users = m

			m = "^(GROUP|total|"
			cmd = "getent group 2> /dev/null"
			while (cmd | getline > 0) {
				if (split($0, f, /:/) < 3) continue
				if (f[3] > 1024 && f[3] !~ /^6553[456]$/)
					continue
				m = m f[1] "|"
			}
			close(cmd)
			m = m "\\*)$"
			unredacted_groups = m
		}
	}

	######################################## FUNCTIONS

	function bpftrace_init()
	{
		# Obtain handler (sh) pid
		(cmd = sprintf("pgrep -P %d %s", cpid, comm)) | getline wpid

		# Obtain bpftrace pid
		cmd = sprintf("pgrep -P %d bpftrace", wpid)
		cmd | getline bpid
		close(cmd)
	}

	function debug1(fmt,a1) { if (debugger) printf fmt "\n", a1 }
	function debug2(fmt,a1,a2) { if (debugger) printf fmt "\n", a1, a2 }
	function buffer_add(text) { BUFFER = BUFFER text }

	function print_buffer()
	{
		if (!cons && !output_json) buffer_add("\n")
		printf "%s", BUFFER
		fflush()
	}

	function info(str)
	{
		if (quiet) return
		printf "%sINFO%s %s\n", color ? magenta : "",
			color ? fgreset : "", str > stderr
		fflush(stderr)
	}

	function info_n(str)
	{
		if (quiet) return
		printf "%sINFO%s %s", color ? magenta : "",
			color ? fgreset : "", str > stderr
		fflush(stderr)
	}

	function msg(str)
	{
		if (quiet) return
		print $0 > stderr
		fflush(stderr)
	}

	function warn(str)
	{
		if (quiet) return
		printf "%sWARNING%s %s\n", color ? yellow bold : "",
			color ? fgreset nobold : "", str > stderr
		fflush(stderr)
	}

	function get_random(len,        c, n, r, rdata, rfile, rlen)
	{
		if (len < 1) return ""
		rlen = 0
		rdata = ""
		rfile = "/dev/urandom"
		while (length(rdata) < len && getline r < rfile > 0) {
			for (n = split(r, c, ""); n >= 1; n--) {
				if (c[n] !~ /[\x41-\x5a]/) continue
				rdata = rdata c[n]
				if (++rlen == len) break
			}
		}
		close(rfile)
		return rdata
	}

	function resize(        dsz, vsz, vsz_fixed, bar_size_fixed,
		bar_size_fixed_max, bar_size_fixed_min, bar_min1, bar_min2,
		vfssz, pidsz, commsz, commsz_cols1, commsz_cols2, commsz_cols3,
		sgesz, usersz, usersz_cols1, usersz_cols2, usersz_cols3,
		vsz_cols1, vsz_cols2, vsz_max, vsz_min, wv)
	{
		if (output_json) return

		#
		# Calculate columns and column widths
		# ST: VIEWS
		#
		# NB: bar_size = size of bar column (if shown)
		# NB: commsz = size of COMM column
		# NB: dsz = size of TOTAL, READ(IN), WRITE(OUT) data columns
		# NB: pidsz = size of PID column
		# NB: sgesz = size of SGE column
		# NB: usersz = size of SGE user column
		# NB: vfssz = size of VFS column
		# NB: vsz = size of VIEW column ("view size")
		#
		# If given -w (wide view) make bar_size fixed-width and
		# vsz variable-width.
		#
		# Without -w, make vsz fixed-width and bar_size variable.
		#

		wv = wide_view

		show_bar_column = 1
		show_comm_column = 1
		show_name_column = 1
		show_rw_columns = 1
		show_user_column = 1
		show_vfs_column = 1

		vfssz = 8
		pidsz = 6
		sgesz = 7
		usersz = 8
		usersz_min = length("USER")
		vsz_min = length(view)
		commsz = 15
		commsz_min = length("COMM")
		dsz = show_bytes ? 10 : 12
		bar_size_fixed_max = 21
		bar_size_fixed_min = 11

		if (view == "TYPE" || filter_type || view_aggregates)
			show_vfs_column = 0

		if (view == "PID") {
			vsz_max = 9
			vsz_min = length("USER")

			#
			# Calculate minimum terminal width required (bar_min1)
			# to display small bar (bar_size_fixed_min) and also
			# minimum terminal width required (bar_min2) to display
			# larger bar (bar_size_fixed_max).
			#
			bar_min1 = 0
			if (show_vfs_column)
				bar_min1 += vfssz + 1 # VFS + space
			bar_min1 += pidsz + 1 # PID + space
			bar_min1 += vsz_min + 1 # USER + space
			commsz_cols1 = commsz_cols2 = commsz_cols3 = bar_min1
			vsz_cols2 = bar_min1
			bar_min1 += commsz + 1 # COMM + space
			commsz_cols1 += commsz_min + 1 # COMM + space
			commsz_cols2 += commsz + 1 # COMM + space
			commsz_cols3 += commsz_min + 1 # COMM + space
			bar_min1 += dsz + 1 # TOTAL + space
			commsz_cols1 += dsz + 1 # TOTAL + space
			commsz_cols2 += dsz # TOTAL
			commsz_cols3 += dsz # TOTAL
			vsz_cols2 += dsz # TOTAL
			bar_min1 += dsz + 1 # READ(IN) + space
			commsz_cols1 += dsz + 1 # READ(IN) + space
			vsz_cols1 = bar_min2 = bar_min1
			bar_min1 += bar_size_fixed_min + 1 # small bar + space
			bar_min2 += bar_size_fixed_max + 1 # bigger bar + space
			bar_min1 += dsz # WRITE(OUT)
			bar_min2 += dsz # WRITE(OUT)
			vsz_cols1 += dsz # WRITE(OUT)
			commsz_cols1 += dsz # WRITE(OUT)

			#
			# Calculate fixed bar width based on terminal width
			# NB: Only used in wide-view (-w)
			# NB: If terminal is too narrow, disable bar/columns
			#
			if (cols >= bar_min2) {
				bar_size_fixed = bar_size_fixed_max
			} else if (cols >= bar_min1) {
				bar_size_fixed = bar_size_fixed_min
			} else {
				show_bar_column = 0
				bar_size_fixed = 0
			}

			#
			# Calculate fixed-size "USER" column width
			# NB: Unused in wide-view (-w)
			#
			vsz_fixed = vsz_min
			if (cols >= bar_min2) {
				vsz_fixed += cols - bar_min2
				if (vsz_fixed > vsz_max)
					vsz_fixed = vsz_max
			} else if (cols >= bar_min1) {
				vsz_fixed += cols - bar_min1
				if (vsz_fixed > vsz_max)
					vsz_fixed = vsz_max
			} else if (cols >= vsz_cols1) {
				vsz_fixed += cols - vsz_cols1
			} else if (cols >= commsz_cols1) {
				commsz = commsz_min
				commsz += cols - commsz_cols1
			} else if (cols >= commsz_cols2) {
				show_rw_columns = 0
				wv = 1
			} else if (cols >= commsz_cols3) {
				show_rw_columns = 0
				wv = 1
				commsz -= commsz_cols2 - cols
			} else if (cols >= vsz_cols2) {
				show_rw_columns = 0
				show_comm_column = 0
				wv = 1
			} else {
				show_rw_columns = 0
				show_comm_column = 0
				show_user_column = 0
			}
		} else if (view == "SGE") {
			vsz_max = 15
			vsz_min = length("NAME")

			#
			# Calculate minimum terminal width required (bar_min1)
			# to display small bar (bar_size_fixed_min) and also
			# minimum terminal width required (bar_min2) to display
			# larger bar (bar_size_fixed_max).
			#
			bar_min1 = 0
			if (show_vfs_column)
				bar_min1 += vfssz + 1 # VFS + space
			bar_min1 += sgesz + 1 # SGE + space
			usersz_cols1 = usersz_cols2 = usersz_cols3 = bar_min1
			vsz_cols2 = bar_min1
			bar_min1 += usersz + 1 # USER + space
			usersz_cols1 += usersz_min + 1 # USER + space
			usersz_cols2 += usersz + 1 # USER + space
			usersz_cols3 += usersz_min + 1 # USER + space
			vsz_cols2 += usersz_min + 1 # USER + space
			bar_min1 += vsz_min + 1 # NAME + space
			usersz_cols1 += vsz_min + 1 # NAME + space
			usersz_cols2 += vsz_min + 1 # NAME + space
			usersz_cols3 += vsz_min + 1 # NAME + space
			bar_min1 += dsz + 1 # TOTAL + space
			usersz_cols1 += dsz + 1 # TOTAL + space
			usersz_cols2 += dsz # TOTAL
			usersz_cols3 += dsz # TOTAL
			vsz_cols2 += dsz # TOTAL
			bar_min1 += dsz + 1 # READ(IN) + space
			usersz_cols1 += dsz + 1 # READ(IN) + space
			vsz_cols1 = bar_min2 = bar_min1
			bar_min1 += bar_size_fixed_min + 1 # small bar + space
			bar_min2 += bar_size_fixed_max + 1 # bigger bar + space
			bar_min1 += dsz # WRITE(OUT)
			bar_min2 += dsz # WRITE(OUT)
			vsz_cols1 += dsz # WRITE(OUT)
			usersz_cols1 += dsz # WRITE(OUT)

			#
			# Calculate fixed bar width based on terminal width
			# NB: Only used in wide-view (-w)
			# NB: If terminal is too narrow, disable bar/columns
			#
			if (cols >= bar_min2) {
				bar_size_fixed = bar_size_fixed_max
			} else if (cols >= bar_min1) {
				bar_size_fixed = bar_size_fixed_min
			} else {
				show_bar_column = 0
				bar_size_fixed = 0
			}

			#
			# Calculate fixed-size "NAME" column width
			# NB: Unused in wide-view (-w)
			#
			vsz_fixed = vsz_min
			if (cols >= bar_min2) {
				vsz_fixed += cols - bar_min2
				if (vsz_fixed > vsz_max)
					vsz_fixed = vsz_max
			} else if (cols >= bar_min1) {
				vsz_fixed += cols - bar_min1
				if (vsz_fixed > vsz_max)
					vsz_fixed = vsz_max
			} else if (cols >= vsz_cols1) {
				vsz_fixed += cols - vsz_cols1
			} else if (cols >= usersz_cols1) {
				usersz = usersz_min
				usersz += cols - usersz_cols1
			} else if (cols >= usersz_cols2) {
				show_rw_columns = 0
				wv = 1
			} else if (cols >= usersz_cols3) {
				show_rw_columns = 0
				wv = 1
				usersz -= usersz_cols2 - cols
			} else if (cols >= vsz_cols2) {
				show_rw_columns = 0
				show_name_column = 0
				usersz += cols - usersz_cols3 + 1
			} else {
				show_rw_columns = 0
				show_name_column = 0
				show_user_column = 0
			}
		} else {
			vsz_max = 9
			vsz_min = length(view)

			#
			# Calculate minimum terminal width required (bar_min1)
			# to display small bar (bar_size_fixed_min) and also
			# minimum terminal width required (bar_min2) to display
			# larger bar (bar_size_fixed_max).
			#
			bar_min1 = 0
			if (show_vfs_column)
				bar_min1 += vfssz + 1 # VFS + space
			bar_min1 += vsz_min + 1 # VIEW + space
			bar_min1 += dsz + 1 # TOTAL + space
			vsz_cols2 = bar_min1
			bar_min1 += dsz + 1 # READ(IN) + space
			vsz_cols1 = bar_min2 = bar_min1
			bar_min1 += bar_size_fixed_min + 1 # small bar + space
			bar_min2 += bar_size_fixed_max + 1 # bigger bar + space
			bar_min1 += dsz # WRITE(OUT)
			bar_min2 += dsz # WRITE(OUT)
			vsz_cols1 += dsz # WRITE(OUT)

			#
			# Calculate fixed bar width based on terminal width
			# NB: Only used in wide-view (-w)
			# NB: If terminal is too narrow, disable bar/columns
			#
			if (cols >= bar_min2) {
				bar_size_fixed = bar_size_fixed_max
			} else if (cols >= bar_min1) {
				bar_size_fixed = bar_size_fixed_min
			} else {
				show_bar_column = 0
				bar_size_fixed = 0
			}

			#
			# Calculate fixed-size "VIEW" column width
			# NB: Unused in wide-view (-w)
			#
			vsz_fixed = vsz_min
			if (cols >= bar_min2) {
				vsz_fixed += cols - bar_min2
				if (vsz_fixed > vsz_max)
					vsz_fixed = vsz_max
			} else if (cols >= bar_min1) {
				vsz_fixed += cols - bar_min1
				if (vsz_fixed > vsz_max)
					vsz_fixed = vsz_max
			} else if (cols >= vsz_cols1) {
				vsz_fixed += cols - vsz_cols1
			} else if (cols >= vsz_cols2) {
				show_rw_columns = 0
				wv = 1
			} else {
				show_rw_columns = 0
			}
		}

		if (wv) {
			# Fixed-width
			bar_size = bar_size_fixed

			# Variable-width (%-*s)
			vsz = cols
			if (show_vfs_column) {
				vsz -= vfssz + 1 # VFS + space
			}
			if (view == "PID") {
				#
				# In context of PID-view (-p; default) PIDs are
				# 1-6 digits and COMMs are limited by kernel to
				# 15 characters. USER column benefits most from
				# variable-width column.
				#
				vsz -= pidsz + 1 # PID + space
				if (show_user_column)
					vsz -= 0 + 1 # %-*s USER + space
				if (show_comm_column)
					vsz -= commsz + 1 # COMM + space
			} else if (view == "SGE") {
				#
				# In context of SGE-view (-s) job IDs are 1-7
				# digits and NAMES can be very long. NAME
				# column benefits most from variable-width
				# column.
				#
				vsz -= sgesz + 1 # %7s SGE + space
				if (show_user_column)
					vsz -= 8 + 1 # %-8s USER + space
				if (show_name_column)
					vsz -= 0 + 1 # %-*s NAME + space
			} else {
				vsz -= 0 + 1 # %-*s VIEW + space
			}
			vsz -= dsz # TOTAL
			if (show_rw_columns) {
				vsz -= 1 + dsz + 1 # space + READ(IN) + space
				if (bar_size > 0) {
					vsz -= bar_size + 1 # bar + space
				}
				vsz -= dsz # WRITE(OUT)
			}
		} else if (show_bar_column) {
			# Fixed-width
			vsz = vsz_fixed

			# Variable-width (%-*s)
			bar_size = cols
			if (show_vfs_column) {
				bar_size -= vfssz + 1 # VFS + space
			}
			if (view == "PID") {
				bar_size -= pidsz + 1 # PID + space
				bar_size -= vsz + 1 # %-*s USER + space
				bar_size -= commsz + 1 # COMM + space
			} else if (view == "SGE") {
				bar_size -= sgesz + 1 # SGE + space
				bar_size -= usersz + 1 # USER + space
				bar_size -= vsz + 1 # %-*s NAME + space
			} else {
				bar_size -= vsz + 1 # %[-]*s VIEW + space
			}
			bar_size -= dsz + 1 # TOTAL + space
			bar_size -= dsz + 1 # READ(IN) + space
			bar_size -= 0 + 1 # variable-width bar + space
			bar_size -= dsz # WRITE(OUT)
		} else {
			# Fixed-width
			vsz = vsz_fixed
		}

		if (vsz < vsz_min)
			vsz = vsz_min

		#
		# Calculate format and line width
		# ST: VIEWS
		#

		fmt = ""
		fmtsz = 0

		if (show_vfs_column) {
			fmt = fmt " %-" vfssz "s" # VFS
			fmtsz += 1 + vfssz
		}

		if (view == "PID") {
			fmt = fmt " %" pidsz "s" # PID
			fmtsz += 1 + pidsz
			if (show_user_column) {
				fmt = fmt " %-" vsz "s" # USER
				fmtsz += 1 + vsz
			}
			if (show_comm_column) {
				fmt = fmt " %-" commsz "s" # COMM
				fmtsz += 1 + commsz
			}
		} else if (view == "SGE") {
			fmt = fmt " %" sgesz "s" # SGE
			fmtsz += 1 + sgesz
			if (show_user_column) {
				fmt = fmt " %-" usersz "s" # USER
				fmtsz += 1 + usersz
			}
			if (show_name_column) {
				fmt = fmt " %-" vsz "s" # NAME
				fmtsz += 1 + vsz
			}
		} else {
			fmt = fmt " %-" vsz "s" # VIEW
			fmtsz += 1 + vsz
		}

		fmt = fmt " %" dsz "s" # TOTAL
		fmtsz += 1 + dsz
		if (show_rw_columns) {
			if (color) {
				fmt = fmt " " cyan "%" dsz "s" # READ(IN)
			} else {
				fmt = fmt " %" dsz "s" # READ(IN)
			}
			fmtsz += 1 + dsz
		}

		if (show_bar_column) {
			full_bar = bar_size
			bar_size = int(bar_size / 2)
			if (bar_size * 2 == full_bar) bar_size--
			fmt = fmt " %*s" # read_bar
			if (color) {
				fmt = fmt fgreset "|" red "%-*s" # write_bar
			} else {
				fmt = fmt "|%-*s" # write_bar
			}
			fmtsz += 1 + bar_size + 1 + bar_size
			fmt = fmt " %-" dsz "s" # WRITE(OUT)
			fmtsz += 1 + dsz
		} else if (show_rw_columns) {
			if (color) {
				fmt = fmt " " red "%" dsz "s" # WRITE(OUT)
			} else {
				fmt = fmt " %" dsz "s" # WRITE(OUT)
			}
			fmtsz += 1 + dsz
		}

		fmt = substr(fmt, 2) # Trim leading space
		fmtsz -= 1
		fmt = fmt (color ? fgreset : "") "\n"

		#
		# Export calculated column sizes for things we truncate
		#
		delete csz
		csz["comm"] = commsz
		csz["user"] = usersz
		csz["vfs"] = vfssz
		csz["view"] = vsz

		#
		# Redraw console
		#
		if (cons) {
			clear_buffer()
			buffer_add_data()
			print_buffer()
		}
	}

	function uid2name(uid,        cmd, id, idf, name, n, k, idx, i, ret)
	{
		n = split(uid, k, /, /)
		uid = n < 3 ? k[idx = 2] : k[idx = 3]
		if (uid in uid2name_cache) {
			name = uid2name_cache[uid]
		} else {
			(cmd = sprintf("getent passwd %d", uid)) | getline id
			close(cmd)
			name = split(id, idf, /:/) < 3 ? uid : idf[1]
			if (name == "") name = uid
			uid2name_cache[uid] = name
		}
		ret = ""
		k[idx] = name
		for (i = 1; i <= n; i++)
			ret = ret ", " k[i]
		return substr(ret, 3) # Trim leading ", "
	}

	function gid2name(gid,        cmd, id, idf, name, n, k, idx, i, ret)
	{
		n = split(gid, k, /, /)
		gid = k[idx = 2]
		if (gid in gid2name_cache) {
			name = gid2name_cache[gid]
		} else {
			(cmd = sprintf("getent group %d", gid)) | getline id
			close(cmd)
			name = split(id, idf, /:/) < 3 ? gid : idf[1]
			if (name == "") name = gid
			gid2name_cache[gid] = name
		}
		ret = ""
		k[idx] = name
		for (i = 1; i <= n; i++)
			ret = ret ", " k[i]
		return substr(ret, 3) # Trim leading ", "
	}

	function clear_data()
	{
		# ST: VIEWS
		delete comm_keys
		delete group_keys
		delete pid_keys
		delete sge_keys
		delete type_keys
		delete user_keys

		nviews = 0
		delete map_views
		delete view_list

		delete map_key_read
		delete map_key_write
		delete map_view_read
		delete map_view_write
	}

	function clear_buffer()
	{
		BUFFER = ""
		if (output_json) return
		if (!debugger && cons)
			buffer_add(sprintf("\033[H\033[J"))
		buffer_add_header()
	}

	function buffer_add1(vfs, arg1, total, read, read_bar, write_bar,
		write, prefix, suffix,        str)
	{
		if (length(vfs) > csz["vfs"])
			vfs = substr(vfs, 1, csz["vfs"])
		if (redact && view == "USER") {
			if (arg1 !~ unredacted_users)
				arg1 = get_random(length(arg1))
		} else if (redact && view == "GROUP") {
			if (arg1 !~ unredacted_groups)
				arg1 = get_random(length(arg1))
		}
		if (length(arg1) > csz["view"])
			arg1 = substr(arg1, 1, csz["view"])
		if (show_vfs_column) {
			if (show_bar_column) {
				str = sprintf(fmt, vfs, arg1, total, read,
					bar_size, read_bar, bar_size,
					write_bar, write)
			} else {
				str = sprintf(fmt, vfs, arg1, total, read,
					write)
			}
		} else if (show_bar_column) {
			str = sprintf(fmt, arg1, total, read, bar_size,
				read_bar, bar_size, write_bar, write)
		} else {
			str = sprintf(fmt, arg1, total, read, write)
		}
		if (cols < fmtsz) {
			str = substr(str, 1, cols) (str ~ /\n$/ ? "\n" : "")
		}
		buffer_add(prefix str suffix)
	}

	function buffer_add3(vfs, arg1, arg2, arg3, total, read, read_bar,
		write_bar, write, prefix, suffix,        str, show2, show3)
	{
		if (length(vfs) > csz["vfs"])
			vfs = substr(vfs, 1, csz["vfs"])
		if (redact && arg2 !~ unredacted_users) {
			arg2 = get_random(length(arg2))
			arg3 = get_random(length(arg3))
		}
		if (view == "PID") {
			show3 = show_comm_column
			show2 = show_user_column
			if (length(arg2) > csz["view"])
				arg2 = substr(arg2, 1, csz["view"])
			if (length(arg3) > csz["comm"])
				arg3 = substr(arg3, 1, csz["comm"])
		} else if (view == "SGE") {
			show3 = show_name_column
			show2 = show_user_column
			if (length(arg2) > csz["user"])
				arg2 = substr(arg2, 1, csz["user"])
			if (length(arg3) > csz["view"])
				arg3 = substr(arg3, 1, csz["view"])
		}
		if (show_vfs_column) {
			if (show_bar_column) {
				str = sprintf(fmt, vfs, arg1, arg2, arg3,
					total, read, bar_size, read_bar,
					bar_size, write_bar, write)
			} else if (show_rw_columns) {
				str = sprintf(fmt, vfs, arg1, arg2, arg3,
					total, read, write)
			} else if (show3) {
				str = sprintf(fmt, vfs, arg1, arg2, arg3,
					total)
			} else if (show2) {
				str = sprintf(fmt, vfs, arg1, arg2, total)
			} else {
				str = sprintf(fmt, vfs, arg1, total)
			}
		} else if (show_bar_column) {
			str = sprintf(fmt, arg1, arg2, arg3, total, read,
				bar_size, read_bar, bar_size, write_bar, write)
		} else if (show_rw_columns) {
			str = sprintf(fmt, arg1, arg2, arg3, total, read,
				write)
		} else if (show3) {
			str = sprintf(fmt, arg1, arg2, arg3, total)
		} else if (show2) {
			str = sprintf(fmt, arg1, arg2, total)
		} else {
			str = sprintf(fmt, arg1, total)
		}
		if (cols < fmtsz) {
			str = substr(str, 1, cols) (str ~ /\n$/ ? "\n" : "")
		}
		buffer_add(prefix str suffix)
	}

	function buffer_add_header(        prefix, suffix,
		presz, n, fmt, dtfmt, dtsz, ifmt, sz, str)
	{
		if (output_json) return
		ifmt = "%.3fs"
		presz = 9 + 1 + length(sprintf(ifmt, interval))
			#  9 = "Interval:"
			#  1 = number of spaces
		sz = cols < fmtsz ? cols : fmtsz
		for (n = split("|%T|%F %T|%c", fmt, /\|/); n > 0; n--) {
			dtfmt = fmt[n]
			dtsz = dtfmt == "" ? 0 : length(strftime(dtfmt, tm))
			if (sz >= presz + 1 + dtsz) break
		}
		if (dtfmt == "") {
			str = sprintf("Interval: " ifmt, interval)
			if (length(str) > sz) {
				str = substr(str, 1, sz)
			}
			buffer_add(str "\n")
		} else {
			buffer_add(sprintf("Interval: %-*s %*s\n",
				sz - 9 - 2 - dtsz, sprintf(ifmt, interval),
				dtsz, strftime(dtfmt, tm)))
					#  9 = "Interval:"
					#  2 = number of spaces
		}
		prefix = color ? inv green : ""
		suffix = color ? fgreset noinv : ""
		empty_bar = ""
		# ST: VIEWS
		if (view == "PID") {
			buffer_add3("VFS", view, "USER", "COMM", "TOTAL",
				"READ(IN)", empty_bar, empty_bar, "WRITE(OUT)",
				prefix, suffix)
		} else if (view == "SGE") {
			buffer_add3("VFS", view, "USER", "NAME", "TOTAL",
				"READ(IN)", empty_bar, empty_bar, "WRITE(OUT)",
				prefix, suffix)
		} else {
			buffer_add1("VFS", view == "TYPE" ? "VFS" : view,
				"TOTAL", "READ(IN)", empty_bar, empty_bar,
				"WRITE(OUT)", prefix, suffix)
		}
	}

	function buffer_add_data()
	{
		#
		# Process each requested view
		#
		for (v = 1; v <= nviews; v++)
			process_view(view_list[v])
	}

	function load_keys(map_view,        map_key)
	{
		delete _keys
		# ST: VIEWS
		if (map_view == "comm") for (map_key in comm_keys)
			_keys[map_key] = comm_keys[map_key]
		else if (map_view == "group") for (map_key in group_keys)
			_keys[map_key] = group_keys[map_key]
		else if (map_view == "pid") for (map_key in pid_keys)
			_keys[map_key] = pid_keys[map_key]
		else if (map_view == "sge") for (map_key in sge_keys)
			_keys[map_key] = sge_keys[map_key]
		else if (map_view == "type") for (map_key in type_keys)
			_keys[map_key] = type_keys[map_key]
		else if (map_view == "user") for (map_key in user_keys)
			_keys[map_key] = user_keys[map_key]
	}

	function parse_map()
	{
		# ST: TRACEDATA
		if (!match($0, /^@[^\[]*\[/)) return 0
		map_name = substr($0, RSTART + 1, RLENGTH - 2)
		map_view = substr(map_name, 4)
		map_op = substr(map_name, 1, 2) # rd/wr

		if (!match($0, /\[.*\]:/)) return 0
		map_key = substr($0, RSTART + 1, RLENGTH - 3)
		nkeys = split(map_key, map_keys, /, /)
		map_value = $NF

		#
		# ST: FILTERS
		#

		if (want_sge != "") {
			if (map_view == "pid")
				job_pid = map_keys[5]
			else if (map_view == "sge")
				job_pid = map_keys[2]
			else
				job_pid = ""
			if (!(job_pid in jobcache)) return
		}
		if (want_sge == "id") {
			if (jobcache[job_pid] != filter_sge) return
		} else if (want_sge == "regex") {
			if (!(job_pid in jobcache)) return
			if (filter_sge !~ jobcache[job_pid] &&
				filter_sge !~ namecache[job_pid]) return
		}

		#
		# ST: SUBTOTALS
		#

		map_skey = ""
		if (show_aggregates) {
			map_skey = "*"
			for (n = 2; n <= nkeys; n++)
				map_skey = map_skey ", " map_keys[n]
		}

		#
		# ST: VIEWS
		#

		if (!(map_view in map_views)) {
			map_views[map_view]
			view_list[++nviews] = map_view
		}

		if (map_view == "comm") {
			comm_keys[map_key]
			if (map_skey != "") comm_keys[map_skey]
		} else if (map_view == "group") {
			group_keys[map_key]
			if (map_skey != "") group_keys[map_skey]
		} else if (map_view == "pid") {
			pid_keys[map_key]
			if (map_skey != "") pid_keys[map_skey]
		} else if (map_view == "sge") {
			sge_keys[map_key]
			if (map_skey != "") sge_keys[map_skey]
		} else if (map_view == "type") {
			type_keys[map_key]
			if (map_skey != "") type_keys[map_skey]
		} else if (map_view == "user") {
			user_keys[map_key]
			if (map_skey != "") user_keys[map_skey]
		}

		#
		# ST: OPS
		#

		if (map_op == "rd") {
			map_view_read[map_view] += map_value
			map_key_read[map_view, map_key] = map_value
			if (map_skey != "")
				map_key_read[map_view, map_skey] += map_value
		} else { # wr
			map_view_write[map_view] += map_value
			map_key_write[map_view, map_key] = map_value
			if (map_skey != "")
				map_key_write[map_view, map_skey] += map_value
		}

		return 1
	}

	function humanize(value,        raw, n, suffix, suffixes)
	{
		raw = value
		n = split(",K,M,G,T,E", suffixes, /,/)
		for (suffix = 1; suffix <= n; suffix++) {
			if (int(value) < 1024) break
			value /= 1024
		}
		if (v ~ /\./) sub(/\.?0+$/, "", v)
		value = sprintf("%'"'"'.2f%s%s", value, suffixes[suffix],
			show_bytes ? "B" : "B/s")
		return value
	}

	function _asort(src, dest,        k, nitems, i, val)
	{
		k = nitems = 0
		for (i in src) dest[++nitems] = src[i]
		for (i = 1; i <= nitems; k = i++) {
			val = dest[i]
			while ((k > 0) && (dest[k] > val)) {
				dest[k+1] = dest[k]; k--
			}
			dest[k+1] = val
		}
		return nitems
	}

	function json_add(json, key, format, value)
	{
		return json (length(json) < 2 ? "" : ",") \
			sprintf("\"%s\":" format, key, value)
	}

	function json_add_str(json, key, value)
	{
		return json_add(json, key, "\"%s\"", value)
	}

	function json_add_uint(json, key, value)
	{
		return json_add(json, key, "%u", value)
	}

	function json_add_prec(json, key, precision, value,        x)
	{
		x = sprintf("%.*f", precision, value)
		if (x ~ /\./) sub(/\.?0+$/, "", x)
		return json_add(json, key, "%s", x)
	}

	function json_add_float(json, key, value)
	{
		return json_add_prec(json, key, 12, value)
	}

	function sample_check()
	{
		if (nsamples > 0 && --samples_left < 1) {
			if (bpid == "") {
				cmd = sprintf("pgrep -P %d bpftrace", cpid)
				cmd | getline bpid
				close(cmd)
			}
			if (bpid != "") {
				system(sprintf("kill %d > /dev/null 2>&1",
					bpid))
			}
			if (more) printf "\n"
			exit
		}
	}

	function process_view(curview,
		read_bar, read_rate, read_total,
		write_bar, write_rate, write_total,
		rw_rate, rw_total,
		_keys_sorted, cred, i, v, r, n, table_rows)
	{
		time_delta = times[2] - times[1]
		if (time_delta < 1) time_delta = 1 # prevent division-by-0
		debug1("Time delta is %d seconds", time_delta)

		read_total = map_view_read[curview]
		read_rate = read_total / time_delta
		read_bar = ""

		write_total = map_view_write[curview]
		write_rate = write_total / time_delta
		write_bar = ""

		rw_total = read_total + write_total
		rw_rate = rw_total / time_delta

		if (output_json) {
			json_out = ""
			json_out = json_add_uint(json_out, "time", tm)
			json_out = json_add_str(json_out,
				"ident", "total_" curview)
			json_out = json_add_uint(json_out,
				"total_bytes", rw_total)
			json_out = json_add_float(json_out,
				"total_rate", rw_rate)
			json_out = json_add_uint(json_out,
				"read_bytes", read_total)
			json_out = json_add_float(json_out,
				"read_rate", read_rate)
			json_out = json_add_uint(json_out,
				"write_bytes", write_total)
			json_out = json_add_float(json_out,
				"write_rate", write_rate)
			buffer_add("{" json_out "}\n")
		} else if (show_bytes) {
			# ST: VIEWS
			if (view == "PID" || view == "SGE") {
				buffer_add3("*", "total", "*", "*",
					humanize(rw_total),
					humanize(read_total), read_bar,
					write_bar, humanize(write_total))
			} else {
				buffer_add1("*", "total",
					humanize(rw_total),
					humanize(read_total), read_bar,
					write_bar, humanize(write_total))
			}
		} else {
			# ST: VIEWS
			if (view == "PID" || view == "SGE") {
				buffer_add3("*", "total", "*", "*",
					humanize(rw_rate),
					humanize(read_rate), read_bar,
					write_bar, humanize(write_rate))
			} else {
				buffer_add1("*", "total",
					humanize(rw_rate),
					humanize(read_rate), read_bar,
					write_bar, humanize(write_rate))
			}
		}

		#
		# Decorate combined read/write values
		#
		load_keys(curview)
		for (cred in _keys) {
			v = int(map_key_read[curview, cred]) + \
				int(map_key_write[curview, cred])
			if (cred ~ /^\*, /) v++ # Sort subtotals above
			_keys[cred] = sprintf("%99d %s", v, cred)
		}

		#
		# Print subtotals
		#
		r = 1
		n = _asort(_keys, _keys_sorted)
		table_rows = output_json || !cons ? n : rows - 4
		for (i = n; i >= 1 && r <= table_rows; i--) {
			debug2("r=[%d] table_rows=[%d]", r, table_rows)
			cred = _keys_sorted[i]
			sub(/^ *[^ ]+ +/, "", cred) # Undecorate
			r += process_cred(curview, cred,
				read_total, write_total)
		}
		if (more = i > 0) buffer_add(sprintf("%s(%d more) ... %s",
			color ? inv bold yellow : "", i,
			color ? noinv nobold fgreset : ""))
	}

	function process_cred(curview, cred, read_total, write_total,
		cred_read, read_bar, read_bar_pct, read_bar_size, read_rate,
		cred_write, write_bar, write_bar_pct, write_bar_size,
		write_rate, cred_rw, rw_rate, pch, _cred, key)
	{
		pch = "="
		if (show_aggregates) {
			if (curview == "type") {
				if (cred != "*") {
					if (view_aggregates) return 0
				} else {
					if (output_json) return 0
				}
			} else {
				if (cred !~ /^\*, /) {
					if (view_aggregates) return 0
					pch = "-"
				}
			}
		}
		debug1("-> process_cred(curview = %s, ...)", curview)
		debug1("+ cred=[%s]", cred)

		cred_read = map_key_read[curview, cred]
		cred_write = map_key_write[curview, cred]
		cred_rw = cred_read + cred_write

		read_rate = cred_read / time_delta
		if (read_total > 0)
			read_bar_pct = cred_read / read_total
		else
			read_bar_pct = 0
		read_bar_size = bar_size * read_bar_pct
		read_bar = sprintf("%*s", read_bar_size, "")
		gsub(/ /, pch, read_bar)
		sub(/^./, "<", read_bar)

		write_rate = cred_write / time_delta
		if (write_total > 0)
			write_bar_pct = cred_write / write_total
		else
			write_bar_pct = 0
		write_bar_size = bar_size * write_bar_pct
		write_bar = sprintf("%*s", write_bar_size, "")
		gsub(/ /, pch, write_bar)
		sub(/.$/, ">", write_bar)

		if (!no_names) {
			_cred = cred
			if (curview == "group") {
				cred = gid2name(cred)
			} else if (curview == "user" || curview == "pid" ||
				curview == "sge") {
				cred = uid2name(cred)
			}
			if (cred != _cred) debug1("+ cred=[%s]", cred)
		}

		rw_rate = cred_rw / time_delta
		if (curview != "type") {
			# ST: TRACEDATA
			split(cred, key, /, /)
			fstype = key[1]
			cred = key[2]
			if (curview == "pid") {
				user = key[3]
				comm = key[4]
				pid = key[5]
				job = pid in jobcache ? jobcache[pid] : ""
				name = pid in namecache ? namecache[pid] : ""
			} else if (curview == "sge") {
				user = key[3]
				name = cred in namecache ? namecache[cred] : ""
				if (cred in jobcache)
					cred = jobcache[cred]
			}
		}
		if (output_json) {
			# ST: JSONDATA
			json_out = ""
			json_out = json_add_uint(json_out, "time", tm)
			json_out = json_add_str(json_out, "ident", curview)
			if (curview == "type") {
				json_out = json_add_str(json_out,
					curview, cred)
			} else if (curview == "pid") {
				json_out = json_add_str(json_out,
					curview, cred)
				json_out = json_add_str(json_out,
					"fstype", fstype)
				if (redact && user !~ unredacted_users) {
					user = get_random(length(user))
					comm = get_random(length(comm))
				}
				json_out = json_add_str(json_out,
					"user", user)
				json_out = json_add_str(json_out,
					"comm", comm)
				if (job != "") {
					json_out = json_add_str(json_out,
						"sge", job)
					json_out = json_add_str(json_out,
						"name", name)
				}
			} else if (curview == "sge") {
				json_out = json_add_str(json_out,
					curview, cred)
				json_out = json_add_str(json_out,
					"fstype", fstype)
				if (redact && user !~ unredacted_users) {
					user = get_random(length(user))
					name = get_random(length(name))
				}
				json_out = json_add_str(json_out,
					"user", user)
				json_out = json_add_str(json_out,
					"name", name)
			} else {
				if (redact && curview == "user") {
					if (cred !~ unredacted_users)
						cred = get_random(length(cred))
				} else if (redact && curview == "group") {
					if (cred !~ unredacted_groups)
						cred = get_random(length(cred))
				}
				json_out = json_add_str(json_out,
					curview, cred)
				json_out = json_add_str(json_out,
					"fstype", fstype)
			}
			json_out = json_add_uint(json_out,
				"total_bytes", cred_rw)
			json_out = json_add_float(json_out,
				"total_rate", rw_rate)
			json_out = json_add_uint(json_out,
				"read_bytes", cred_read)
			json_out = json_add_float(json_out,
				"read_rate", read_rate)
			json_out = json_add_uint(json_out,
				"write_bytes", cred_write)
			json_out = json_add_float(json_out,
				"write_rate", write_rate)
			buffer_add("{" json_out "}\n")
		} else if (show_bytes) {
			# ST: VIEWDATA
			if (curview == "pid") {
				buffer_add3(fstype, cred, user, comm,
					humanize(cred_rw),
					humanize(cred_read), read_bar,
					write_bar, humanize(cred_write))
			} else if (curview == "sge") {
				buffer_add3(fstype, cred, user, name,
					humanize(cred_rw),
					humanize(cred_read), read_bar,
					write_bar, humanize(cred_write))
			} else {
				buffer_add1(fstype, cred, humanize(cred_rw),
					humanize(cred_read), read_bar,
					write_bar, humanize(cred_write))
			}
		} else {
			# ST: VIEWDATA
			if (curview == "pid") {
				buffer_add3(fstype, cred, user, comm,
					humanize(rw_rate),
					humanize(read_rate), read_bar,
					write_bar, humanize(write_rate))
			} else if (curview == "sge") {
				buffer_add3(fstype, cred, user, name,
					humanize(rw_rate),
					humanize(read_rate), read_bar,
					write_bar, humanize(write_rate))
			} else {
				buffer_add1(fstype, cred, humanize(rw_rate),
					humanize(read_rate), read_bar,
					write_bar, humanize(write_rate))
			}
		}

		return 1
	}

	function getjob(pid,        file, L, nv, env, n, ev, found)
	{
		found = 0
		job_id = job_name = ""
		file = sprintf("/proc/%d/environ", pid)
		while (getline L < file > 0) {
			nv = split(L, env, /\0/)
			for (n = 1; n <= nv; n++) {
				ev = env[n]
				if (sub(/^JOB_ID=/, "", ev)) {
					job_id = ev
				} else if (sub(/^JOB_NAME=/, "", ev)) {
					job_name = ev
				}
				if (job_id != "" && job_name != "") {
					found = 1
					break
				}
			}
			if (found) break
		}
		close(file)
		return job_id != ""
	}

	function sge_encache(job_pid)
	{
		if (!getjob(job_pid)) return 0
		namecache[job_pid] = job_name
		return jobcache[job_pid] = job_id
	}

	function sge_decache(job_pid)
	{
		job_id = jobcache[job_pid]
		job_name = namecache[job_pid]
		delete jobcache[job_pid]
		delete namecache[job_pid]
		return job_id
	}

	######################################## MAIN

	sub(/^EXIT:/, "") { exit_status = $0; next }
	debug { sub(/^\t/, ""); print; next }

	raw_view {
		print

		# Exit if no more samples desired
		if (/^---$/) sample_check()

		if (!debugger) next
	}

	#
	# ST: TRACEDATA
	#

	/^===/ { # Data start
		read_total = write_total = 0
		clear_data()
		clear_buffer()
		next
	}

	/^@/ { parse_map(); next } # Data

	/^---$/ { # Data end
		buffer_add_data()

		#
		# Dump information
		#
		print_buffer()
		sample_check() # Exit if no more samples desired
		next
	}

	#
	# ST: CALLS
	#

	{ call = "" }

	match($0, /^[_a-z]+(-[_a-z]+)?\|/) {
		call = substr($0, 1, RLENGTH - 1)
		$0 = substr($0, RSTART + RLENGTH)
	}

	call == "info" { if (!output_json) info($0) }
	call == "info-n" { if (!output_json) info_n($0) }
	call == "init" { bpftrace_init() }
	call == "msg" { if (!output_json) msg($0) }
	call == "warn" { warn($0) }

	call == "resize" {
		if (output_json) next
		rows = $1
		cols = $2
		resize()
	}

	call == "time" {
		times[1] = times[2]
		times[2] = tm = $0
	}

	call == "fork_job" { sge_encache($0) }
	call == "job_exit" && job_id = sge_decache($0) {
		if (want_sge != "id" || filter_follow) next
		if (job_id != filter_sge) next
		if (!output_json) info(sprintf("SGE job %d exited", job_id))
		exit
	}

	################################################## END

	END { exit exit_status }
' # END-QUOTE

################################################################################
# END
################################################################################
# Local Variables:
# mode: sh
# tab-width: 8
# sh-basic-offset: 8
# indent-tabs-mode: t
# backward-delete-char-untabify-method: nil
# End:
